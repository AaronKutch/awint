use std::{
    fmt::Write,
    fs::{File, OpenOptions},
};

use awint_macro_internals::{cc_macro, CodeGen, FnNames, AWINT_NAMES};

const TEST_FN_NAMES: FnNames = FnNames {
    get_bw: "bw",
    mut_bits_ref: "&mut B",
    bits_ref: "&B",
    le_fn: "le",
    common_fn: "c_fn",
    max_fn: "max",
    copy_assign: "copy",
    field: "field",
    field_to: "field_to",
    field_from: "field_from",
    unwrap: ".unwrap()",
    bw_call: &['.', 'b', 'w', '(', ')'],
};

fn cc(mut f: impl Write, input: &str) {
    let code_gen = CodeGen {
        static_width: false,
        return_type: None,
        must_use: |s| format!("mu({})", s),
        lit_construction_fn: |awi| format!("lit({})", awi),
        construction_fn: |s, w, d| {
            format!(
                "awi({},{:?},{:?})",
                if s.is_empty() { "zero" } else { s },
                w,
                d
            )
        },
        fn_names: TEST_FN_NAMES,
    };
    match cc_macro(input, code_gen, AWINT_NAMES) {
        Ok(s) => {
            writeln!(f, "{}\nOk:\n{}\n\n", input, s).unwrap();
        }
        Err(e) => {
            writeln!(f, "{}\nErr:\n{}\n\n", input, e).unwrap();
        }
    }
}

fn static_cc(mut f: impl Write, input: &str) {
    let code_gen = CodeGen {
        static_width: true,
        return_type: Some("StaticAwi"),
        must_use: |s| format!("mu({})", s),
        lit_construction_fn: |awi| format!("lit({})", awi),
        construction_fn: |s, w, d| {
            format!(
                "awi({},{:?},{:?})",
                if s.is_empty() { "zero" } else { s },
                w,
                d
            )
        },
        fn_names: TEST_FN_NAMES,
    };
    match cc_macro(input, code_gen, AWINT_NAMES) {
        Ok(s) => {
            writeln!(f, "{}\nOk:\n{}\n\n", input, s).unwrap();
        }
        Err(e) => {
            writeln!(f, "{}\nErr:\n{}\n\n", input, e).unwrap();
        }
    }
}

fn dynamic_cc(mut f: impl Write, input: &str) {
    let code_gen = CodeGen {
        static_width: false,
        return_type: Some("DynamicAwi"),
        must_use: |s| format!("mu({})", s),
        lit_construction_fn: |awi| format!("lit({})", awi),
        construction_fn: |s, w, d| {
            format!(
                "awi({},{:?},{:?})",
                if s.is_empty() { "zero" } else { s },
                w,
                d
            )
        },
        fn_names: TEST_FN_NAMES,
    };
    match cc_macro(input, code_gen, AWINT_NAMES) {
        Ok(s) => {
            writeln!(f, "{}\nOk:\n{}\n\n", input, s).unwrap();
        }
        Err(e) => {
            writeln!(f, "{}\nErr:\n{}\n\n", input, e).unwrap();
        }
    }
}

fn main() {
    let mut s = "Generated by `macro_outputs.rs`. Note: see the vt100-syntax-highlighting vscode \
                 extension and select preview on the file.\n\n"
        .to_owned();

    // all errors

    // initial parsing
    cc(&mut s, "0(1[2{34)5]6}7");
    cc(&mut s, "xx[[x(((x)))x]]x}}x");
    cc(&mut s, "x{x[x(((x)))x]]]x}x");
    cc(&mut s, "x{x[[x((x))))x]]x}x");
    cc(&mut s, "x,,");
    cc(&mut s, "x,;,");
    cc(&mut s, "x,;;");
    cc(&mut s, "");

    // component level
    cc(&mut s, "zero: , x; x");
    cc(&mut s, "[..]");
    cc(&mut s, "0u0");
    cc(&mut s, "-123");
    // this follows normal rust rules
    cc(&mut s, "x[..-1]");
    cc(&mut s, "x[-1..]");
    cc(&mut s, "x[..(-1)]");
    cc(&mut s, "x[(-1)..]");
    cc(&mut s, "x[1..0]");
    cc(&mut s, "x[(r+1)..r]");
    cc(&mut s, "x[1..1]");
    cc(&mut s, "x[r..r]");
    cc(&mut s, "0u8[8..]");
    cc(&mut s, "0u8[..9]");
    cc(&mut s, "0u8[r..(r + 9)]");
    cc(&mut s, "1..");
    cc(&mut s, "x[0..1..2]");
    cc(&mut s, "x[0..=1..=2]");
    cc(&mut s, "x[0...1]");

    // concatenation level
    cc(&mut s, "x; 0u8");
    cc(&mut s, "x; ..");
    cc(&mut s, ".., ..");
    cc(&mut s, "x[r..(r+7)]; x[(r-7)..(r+1)]");
    cc(&mut s, "x[r..(r+7)]; x[(r-7)..(r+1)]");

    let mut f = OpenOptions::new()
        .truncate(true)
        .create(true)
        .write(true)
        .open("./testcrate/assets/macro_outputs.vt100")
        .unwrap();
    <File as std::io::Write>::write_all(&mut f, s.as_bytes()).unwrap();
}
